use es_fluent::ThisFtl as _;
use gpui::{
    App, AppContext as _, Context, Entity, Focusable, ParentElement, Render, Styled, Subscription,
    Window,
};
use gpui_component::{
    ActiveTheme, h_flex,
    table::{Table, TableState},
    v_flex,
};
use some_lib::structs::filter_showcase::{
    FilterShowcase, FilterShowcaseFilterEntities, FilterShowcaseTableDelegate,
};

#[gpui_storybook::story_init]
pub fn init(_cx: &mut App) {}

#[gpui_storybook::story]
pub struct FilterShowcaseStory {
    table: Entity<TableState<FilterShowcaseTableDelegate>>,
    /// Original unfiltered data (for client-side filtering demo)
    all_rows: Vec<FilterShowcase>,
    /// All filter UI entities (generated by macro)
    filters: FilterShowcaseFilterEntities,
    _subscription: Subscription,
}

impl gpui_storybook::Story for FilterShowcaseStory {
    fn title() -> String {
        FilterShowcase::this_ftl()
    }

    fn new_view(window: &mut Window, cx: &mut App) -> Entity<impl Render + Focusable> {
        Self::view(window, cx)
    }
}

impl Focusable for FilterShowcaseStory {
    fn focus_handle(&self, cx: &gpui::App) -> gpui::FocusHandle {
        self.table.focus_handle(cx)
    }
}

impl FilterShowcaseStory {
    pub fn view(window: &mut Window, cx: &mut App) -> Entity<Self> {
        cx.new(|cx| Self::new(window, cx))
    }

    /// Apply all filters and update the table rows using generated matches_filters
    fn apply_filters(&mut self, cx: &mut Context<Self>) {
        self.table.update(cx, |table, _cx| {
            let filters = &table.delegate().filters;

            // Use the generated matches_filters method for client-side filtering
            let filtered: Vec<FilterShowcase> = self
                .all_rows
                .iter()
                .filter(|row| row.matches_filters(filters))
                .cloned()
                .collect();

            table.delegate_mut().rows = filtered;
        });
        cx.notify();
    }

    fn new(window: &mut Window, cx: &mut Context<Self>) -> Self {
        let delegate = FilterShowcaseTableDelegate::new(vec![]);
        let table = cx.new(|cx| TableState::new(delegate, window, cx));

        // Trigger initial load via load_more
        table.update(cx, |table, cx| {
            table.delegate_mut().load_more_data(window, cx);
        });

        // Build all filter entities using the generated builder
        // No on_change callback needed since we observe the table
        let filters = FilterShowcaseFilterEntities::build(&table, None, cx);

        let _subscription = cx.observe(&table, |this, _, cx| {
            // Update all_rows when new data is loaded, then apply filters
            let current_rows = this.table.read(cx).delegate().rows.clone();
            if current_rows.len() > this.all_rows.len() {
                this.all_rows = current_rows;
            }
            this.apply_filters(cx);
        });

        Self {
            table,
            all_rows: vec![],
            filters,
            _subscription,
        }
    }
}

impl Render for FilterShowcaseStory {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl gpui::IntoElement {
        let table = self.table.read(cx);
        let delegate = table.delegate();

        v_flex()
            .size_full()
            .gap_4()
            .p_4()
            // Text Filters row - using generated helper
            .child(
                v_flex()
                    .gap_1()
                    .child(
                        gpui::div()
                            .text_xs()
                            .text_color(cx.theme().muted_foreground)
                            .child("Text Filters"),
                    )
                    .child(self.filters.text_filters()),
            )
            // Number Range Filters row - using generated helper
            .child(
                v_flex()
                    .gap_1()
                    .child(
                        gpui::div()
                            .text_xs()
                            .text_color(cx.theme().muted_foreground)
                            .child("Number Range Filters"),
                    )
                    .child(self.filters.number_filters()),
            )
            // Faceted Filters row - using generated helper
            .child(
                v_flex()
                    .gap_1()
                    .child(
                        gpui::div()
                            .text_xs()
                            .text_color(cx.theme().muted_foreground)
                            .child("Faceted Filters"),
                    )
                    .child(self.filters.faceted_filters()),
            )
            // Date Range Filters row - using generated helper
            .child(
                v_flex()
                    .gap_1()
                    .child(
                        gpui::div()
                            .text_xs()
                            .text_color(cx.theme().muted_foreground)
                            .child("Date Range Filters"),
                    )
                    .child(self.filters.date_filters()),
            )
            // Status bar
            .child(
                h_flex()
                    .gap_4()
                    .child(format!(
                        "Showing: {} / {} rows",
                        delegate.rows.len(),
                        self.all_rows.len()
                    ))
                    .child(if delegate.eof {
                        "All data loaded"
                    } else {
                        "More data available"
                    }),
            )
            // Table
            .child(
                Table::new(&self.table)
                    .stripe(true)
                    .scrollbar_visible(true, true),
            )
    }
}
