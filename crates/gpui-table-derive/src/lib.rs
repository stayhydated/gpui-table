mod __crate_paths;

use __crate_paths::gpui::{AnyElement, App, Context, Div, IntoElement, Stateful, Window};
use __crate_paths::gpui_component::table::{Column, ColumnFixed, TableDelegate, TableState};

use proc_macro::TokenStream;
use quote::quote;
use syn::{Data, DeriveInput, Fields, Lit, parse_macro_input};

#[proc_macro_derive(NamedTableRow, attributes(table))]
pub fn derive_named_table_row(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    match expand_named_table_row(&input) {
        Ok(ts) => ts.into(),
        Err(err) => err.to_compile_error().into(),
    }
}

struct FieldConfig {
    ident: syn::Ident,
    col_key: String,
    title: String,
    title_from_attr: bool,
    width: Option<f32>,
    sortable: bool,
    text_right: bool,
    fixed: Option<String>, // "left" or "right"
    #[allow(dead_code)]
    style: Option<String>,
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

fn to_pascal_case(s: &str) -> String {
    let trimmed = s.strip_prefix("r#").unwrap_or(s);
    trimmed
        .split('_')
        .filter(|part| !part.is_empty())
        .map(capitalize_first)
        .collect::<String>()
}

#[derive(Default)]
enum FluentConfig {
    /// No fluent integration.
    #[default]
    None,
    /// Use a specific fluent key (e.g., "description" -> {Struct}DescriptionFtl).
    Key(String),
    /// Use the default fluent enum generated by `EsFluentKv` (e.g., {Struct}Ftl).
    Flag,
}

fn expand_named_table_row(input: &DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    let struct_name = &input.ident;

    let mut table_id = struct_name.to_string();
    let mut table_title = struct_name.to_string();
    let mut delegate = true;
    let mut fluent_config = FluentConfig::None;

    for attr in &input.attrs {
        if attr.path().is_ident("table") {
            attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("id") {
                    if let Ok(Lit::Str(lit)) = meta.value()?.parse() {
                        table_id = lit.value();
                    }
                } else if meta.path.is_ident("title")
                    && let Ok(Lit::Str(lit)) = meta.value()?.parse()
                {
                    table_title = lit.value();
                } else if meta.path.is_ident("delegate") {
                    if let Ok(Lit::Bool(lit)) = meta.value()?.parse() {
                        delegate = lit.value;
                    }
                } else if meta.path.is_ident("fluent") {
                    // Accept either `fluent = "key"` or a bare `fluent` flag.
                    if meta.input.peek(syn::Token![=]) {
                        if let Ok(Lit::Str(lit)) = meta.value()?.parse() {
                            fluent_config = FluentConfig::Key(lit.value());
                        }
                    } else {
                        fluent_config = FluentConfig::Flag;
                    }
                }
                Ok(())
            })?;
        }
    }

    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => fields,
            _ => {
                return Err(syn::Error::new_spanned(
                    input,
                    "NamedTableRow only supports named fields",
                ));
            },
        },
        _ => {
            return Err(syn::Error::new_spanned(
                input,
                "NamedTableRow only supports structs",
            ));
        },
    };

    let mut field_configs = Vec::new();

    for field in &fields.named {
        let ident = field.ident.clone().unwrap();
        let mut col_key = ident.to_string();
        let mut title = ident.to_string(); // Default title is field name
        // Capitalize first letter of default title
        title = capitalize_first(&title);

        let mut width = None;
        let mut sortable = false;
        let mut text_right = false;
        let mut fixed = None;
        let mut style = None;
        let mut is_table_col = false;
        let mut title_from_attr = false;
        let mut skip = false;

        for attr in &field.attrs {
            if attr.path().is_ident("table") {
                is_table_col = true;
                attr.parse_nested_meta(|meta| {
                    if meta.path.is_ident("col") {
                        if let Ok(Lit::Str(lit)) = meta.value()?.parse() {
                            col_key = lit.value();
                        }
                    } else if meta.path.is_ident("title") {
                        if let Ok(Lit::Str(lit)) = meta.value()?.parse() {
                            title = lit.value();
                            title_from_attr = true;
                        }
                    } else if meta.path.is_ident("width") {
                        if let Ok(Lit::Float(lit)) = meta.value()?.parse() {
                            width = Some(lit.base10_parse::<f32>()?);
                        } else if let Ok(Lit::Int(lit)) = meta.value()?.parse() {
                            width = Some(lit.base10_parse::<f32>()?);
                        }
                    } else if meta.path.is_ident("fixed") {
                        if let Ok(Lit::Str(lit)) = meta.value()?.parse() {
                            fixed = Some(lit.value());
                        }
                    } else if meta.path.is_ident("style") {
                        if let Ok(Lit::Str(lit)) = meta.value()?.parse() {
                            style = Some(lit.value());
                        }
                    } else if meta.path.is_ident("sortable") {
                        sortable = true;
                    } else if meta.path.is_ident("text_right") {
                        text_right = true;
                    } else if meta.path.is_ident("skip") {
                        skip = true;
                    }
                    Ok(())
                })?;
            }
        }

        if skip {
            continue;
        }

        if is_table_col {
            field_configs.push(FieldConfig {
                ident,
                col_key,
                title,
                title_from_attr,
                width,
                sortable,
                text_right,
                fixed,
                style,
            });
        }
    }

    let fluent_enum_ident = match &fluent_config {
        FluentConfig::Key(key) => {
            let key_capitalized = capitalize_first(key);
            Some(syn::Ident::new(
                &format!("{}{}{}", struct_name, key_capitalized, "Ftl"),
                struct_name.span(),
            ))
        },
        FluentConfig::Flag => Some(syn::Ident::new(
            &format!("{}{}", struct_name, "Ftl"),
            struct_name.span(),
        )),
        FluentConfig::None => None,
    };

    let columns_init = field_configs.iter().map(|f| {
        let key = &f.col_key;
        let width = f.width.unwrap_or(100.0); // Default width

        let title_expr = if !f.title_from_attr {
            if let Some(fluent_enum_ident) = &fluent_enum_ident {
                let field_name = to_pascal_case(&f.ident.to_string());
                let fluent_variant_ident = syn::Ident::new(&field_name, f.ident.span());
                quote! { #fluent_enum_ident::#fluent_variant_ident.to_string() }
            } else {
                let title = &f.title;
                quote! { #title }
            }
        } else {
            let title = &f.title;
            quote! { #title }
        };

        let sortable_chain = if f.sortable {
            quote! { .sortable() }
        } else {
            quote! {}
        };

        let text_right_chain = if f.text_right {
            quote! { .text_right() }
        } else {
            quote! {}
        };

        let fixed_chain = match f.fixed.as_deref() {
            Some("left") => quote! { .fixed(#ColumnFixed::Left) },
            Some("right") => quote! { .fixed(#ColumnFixed::Right) },
            _ => quote! {},
        };

        quote! {
            #Column::new(#key, #title_expr)
                .width(#width)
                #sortable_chain
                #text_right_chain
                #fixed_chain
        }
    });

    let cell_value_match_arms = field_configs.iter().enumerate().map(|(i, f)| {
        let ident = &f.ident;
        quote! {
            #i => gpui_table::TableCellValue::from(&self.#ident),
        }
    });

    // Generate fluent-aware table title code
    let table_title_impl = if let Some(fluent_enum_ident) = &fluent_enum_ident {
        quote! {
            fn table_title() -> String {
                #fluent_enum_ident::this_ftl()
            }
        }
    } else {
        quote! {
            fn table_title() -> String {
                Self::TABLE_TITLE.to_string()
            }
        }
    };

    let generated_code = quote! {
        impl gpui_table::TableRowMeta for #struct_name {
            const TABLE_ID: &'static str = #table_id;
            const TABLE_TITLE: &'static str = #table_title;

            #table_title_impl

            fn table_columns() -> &'static [#Column] {
                static COLUMNS: std::sync::OnceLock<Vec<#Column>> = std::sync::OnceLock::new();
                COLUMNS.get_or_init(|| vec![
                    #(#columns_init),*
                ])
            }

            fn cell_value(&self, col_ix: usize) -> gpui_table::TableCellValue {
                match col_ix {
                    #(#cell_value_match_arms)*
                    _ => gpui_table::TableCellValue::String(String::new()),
                }
            }
        }

        impl gpui_table::TableRowStyle for #struct_name {
            fn render_table_cell(
                &self,
                col_ix: usize,
                window: &mut #Window,
                cx: &mut #App,
            ) -> #AnyElement {
                gpui_table::default_render_cell(self, col_ix, window, cx).into_any_element()
            }

            fn render_table_row(
                &self,
                row_ix: usize,
                window: &mut #Window,
                cx: &mut #App,
            ) -> #Stateful<#Div> {
                gpui_table::default_render_row(row_ix, window, cx)
            }
        }
    };

    let delegate_impl = if delegate {
        let delegate_name_str = format!("{}TableDelegate", struct_name);
        let delegate_name = syn::Ident::new(&delegate_name_str, struct_name.span());

        quote! {
            #[derive(gpui_table::derive_new::new)]
            pub struct #delegate_name {
                pub rows: Vec<#struct_name>,
                #[new(default)]
                pub visible_rows: std::ops::Range<usize>,
                #[new(default)]
                pub visible_cols: std::ops::Range<usize>,
                #[new(default)]
                pub eof: bool,
                #[new(default)]
                pub loading: bool,
                #[new(default)]
                pub full_loading: bool,
            }

            impl #TableDelegate for #delegate_name {
                fn columns_count(&self, _: &#App) -> usize {
                    <#struct_name as gpui_table::TableRowMeta>::table_columns().len()
                }

                fn rows_count(&self, _: &#App) -> usize {
                    self.rows.len()
                }

                fn column(&self, col_ix: usize, _: &#App) -> &#Column {
                    &<#struct_name as gpui_table::TableRowMeta>::table_columns()[col_ix]
                }

                fn render_td(
                    &self,
                    row_ix: usize,
                    col_ix: usize,
                    window: &mut #Window,
                    cx: &mut #App,
                ) -> impl #IntoElement {
                    use gpui_table::TableRowStyle;
                    self.rows[row_ix].render_table_cell(col_ix, window, cx)
                }

                fn render_tr(&self, row_ix: usize, window: &mut #Window, cx: &mut #App) -> #Stateful<#Div> {
                    use gpui_table::TableRowStyle;
                    self.rows[row_ix].render_table_row(row_ix, window, cx)
                }

                fn visible_rows_changed(
                    &mut self,
                    visible_range: std::ops::Range<usize>,
                    _: &mut #Window,
                    _: &mut #Context<#TableState<Self>>,
                ) {
                    self.visible_rows = visible_range;
                }

                fn visible_columns_changed(
                    &mut self,
                    visible_range: std::ops::Range<usize>,
                    _: &mut #Window,
                    _: &mut #Context<#TableState<Self>>,
                ) {
                    self.visible_cols = visible_range;
                }

                fn is_eof(&self, _: &#App) -> bool {
                    self.eof
                }

                fn loading(&self, _: &#App) -> bool {
                    self.loading
                }
            }
        }
    } else {
        quote! {}
    };

    let generated_code = quote! {
        #generated_code
        #delegate_impl
    };

    Ok(generated_code)
}
