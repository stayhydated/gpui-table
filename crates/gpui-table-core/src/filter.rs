#[cfg(feature = "chrono")]
use chrono::NaiveDateTime;
use std::collections::HashSet;

#[derive(Clone, Debug, PartialEq)]
pub enum TableFilter {
    Faceted(HashSet<String>),
    #[cfg(feature = "chrono")]
    DateRange(Option<NaiveDateTime>, Option<NaiveDateTime>),
    NumberRange(Option<f64>, Option<f64>),
    Text(String),
}

impl TableFilter {
    pub fn is_empty(&self) -> bool {
        match self {
            TableFilter::Faceted(set) => set.is_empty(),
            #[cfg(feature = "chrono")]
            TableFilter::DateRange(start, end) => start.is_none() && end.is_none(),
            TableFilter::NumberRange(min, max) => min.is_none() && max.is_none(),
            TableFilter::Text(s) => s.is_empty(),
        }
    }
}

#[derive(Clone)]
pub struct FacetedFilterOption {
    pub label: String,
    pub value: String,
    pub count: Option<usize>,
    pub icon: Option<gpui_component::IconName>,
}

impl std::fmt::Debug for FacetedFilterOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FacetedFilterOption")
            .field("label", &self.label)
            .field("value", &self.value)
            .field("count", &self.count)
            .field(
                "icon",
                &if self.icon.is_some() {
                    "Some(IconName)"
                } else {
                    "None"
                },
            )
            .finish()
    }
}

impl PartialEq for FacetedFilterOption {
    fn eq(&self, other: &Self) -> bool {
        self.label == other.label && self.value == other.value && self.count == other.count
        // Ignore icon for equality as IconName doesn't implement PartialEq
    }
}

impl Eq for FacetedFilterOption {}
#[derive(Clone, Debug)]
pub struct FilterConfig {
    pub column_index: usize,
    pub filter_type: FilterType,
}

#[derive(Clone, Debug)]
pub enum FilterType {
    Faceted(Vec<FacetedFilterOption>),
    DateRange,
    NumberRange,
    Text,
}

pub trait Filterable {
    fn options() -> Vec<FacetedFilterOption>;
}

impl Filterable for bool {
    fn options() -> Vec<FacetedFilterOption> {
        vec![
            FacetedFilterOption {
                label: "True".to_string(),
                value: "true".to_string(),
                count: None,
                icon: None,
            },
            FacetedFilterOption {
                label: "False".to_string(),
                value: "false".to_string(),
                count: None,
                icon: None,
            },
        ]
    }
}

/// A collection of active filter values that can be accessed by field name.
///
/// This struct is generated by the `GpuiTable` macro and provides type-safe
/// access to filter values during data fetching operations like `load_more`.
///
/// # Example
/// ```ignore
/// impl MyTableDelegate {
///     pub fn load_more_data(&mut self, _window: &mut Window, cx: &mut Context<TableState<Self>>) {
///         // Access filter values for the request
///         let name_filter = self.filters.text("name");
///         let status_filter = self.filters.faceted("status");
///
///         // Build query with filters...
///     }
/// }
/// ```
#[derive(Clone, Debug, Default)]
pub struct ActiveFilters {
    /// Text filter values indexed by field name
    pub text_filters: std::collections::HashMap<String, String>,
    /// Faceted filter values indexed by field name
    pub faceted_filters: std::collections::HashMap<String, std::collections::HashSet<String>>,
    /// Number range filter values indexed by field name
    pub number_range_filters: std::collections::HashMap<String, (Option<f64>, Option<f64>)>,
    #[cfg(feature = "chrono")]
    /// Date range filter values indexed by field name
    pub date_range_filters:
        std::collections::HashMap<String, (Option<chrono::NaiveDate>, Option<chrono::NaiveDate>)>,
}

impl ActiveFilters {
    /// Create a new empty filter collection.
    pub fn new() -> Self {
        Self::default()
    }

    /// Get the text filter value for a field.
    pub fn text(&self, field: &str) -> Option<&String> {
        self.text_filters.get(field).filter(|s| !s.is_empty())
    }

    /// Get the faceted filter values for a field.
    pub fn faceted(&self, field: &str) -> Option<&std::collections::HashSet<String>> {
        self.faceted_filters.get(field).filter(|s| !s.is_empty())
    }

    /// Get the number range filter value for a field.
    pub fn number_range(&self, field: &str) -> Option<&(Option<f64>, Option<f64>)> {
        self.number_range_filters
            .get(field)
            .filter(|(min, max)| min.is_some() || max.is_some())
    }

    #[cfg(feature = "chrono")]
    /// Get the date range filter value for a field.
    pub fn date_range(
        &self,
        field: &str,
    ) -> Option<&(Option<chrono::NaiveDate>, Option<chrono::NaiveDate>)> {
        self.date_range_filters
            .get(field)
            .filter(|(start, end)| start.is_some() || end.is_some())
    }

    /// Set a text filter value.
    pub fn set_text(&mut self, field: impl Into<String>, value: String) {
        self.text_filters.insert(field.into(), value);
    }

    /// Set a faceted filter value.
    pub fn set_faceted(
        &mut self,
        field: impl Into<String>,
        values: std::collections::HashSet<String>,
    ) {
        self.faceted_filters.insert(field.into(), values);
    }

    /// Set a number range filter value.
    pub fn set_number_range(
        &mut self,
        field: impl Into<String>,
        range: (Option<f64>, Option<f64>),
    ) {
        self.number_range_filters.insert(field.into(), range);
    }

    #[cfg(feature = "chrono")]
    /// Set a date range filter value.
    pub fn set_date_range(
        &mut self,
        field: impl Into<String>,
        range: (Option<chrono::NaiveDate>, Option<chrono::NaiveDate>),
    ) {
        self.date_range_filters.insert(field.into(), range);
    }

    /// Check if any filters are active.
    pub fn has_active_filters(&self) -> bool {
        self.text_filters.values().any(|s| !s.is_empty())
            || self.faceted_filters.values().any(|s| !s.is_empty())
            || self
                .number_range_filters
                .values()
                .any(|(min, max)| min.is_some() || max.is_some())
            || {
                #[cfg(feature = "chrono")]
                {
                    self.date_range_filters
                        .values()
                        .any(|(start, end)| start.is_some() || end.is_some())
                }
                #[cfg(not(feature = "chrono"))]
                {
                    false
                }
            }
    }

    /// Clear all filter values.
    pub fn clear(&mut self) {
        self.text_filters.clear();
        self.faceted_filters.clear();
        self.number_range_filters.clear();
        #[cfg(feature = "chrono")]
        self.date_range_filters.clear();
    }
}
